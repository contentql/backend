# Ideology of Designing ContentQL (Hasura CMS)

Though they are many headless CMS out there, ContentQL still strives to become one a part of it for the following

1. Rather than following the traditional CMS and headless CMS war, we choose to become a headless CMS as our product and also simultaneously support the idea of CMS by providing our full stack services.
2. Many headless CMS out there are yet to support GraphQL, we are a GraphQL first
3. Though there are a couple of the headless CMSs which support GraphQL API, those APIs will never be as powerful as Hasura GraphQL APIs
4. So merging the seamless ness of the `headless CMS` ideology and powerful autogenerated `GraphQL APIs` of Hasura enables to create the best non developer but tech/online/management user experience.

# Implementation

1. We create an admin dashboard which could take inspirations from Strapi, like the `content builder` and `content creator` sections
2. Once the UI for the admin panel was done, we will provide the admin users the ability to create their own fields.
3. We need to ensure that we capture all the necessary minute details we require to create both the `content builder`, `content creator` admin panel sections and simultaneously create the corresponding `tables` in Hasura(nhost).
4. We can use the following intermediate state and save such an intermediate state in the users database. This intermediate state is the `ContentQL Metadata`.
   > ContentQL metadata is separate from Hasura Metadata
5. Example showcase of the `ContentQL` Metadata

```js
const todos = [
  {
    id: 1,
    column_name: 'task',
    column_type: 'text',
    component: 'input',
  },
  {
    id: 2,
    column_name: 'completed',
    column_type: 'boolean',
    component: 'torf',
  },
];
```

> You can also save optional parameters in the metadata like `default_value`, `isNull`, `isUnique` etc. 6. Now we need to use the above data to construct our `content builder`, `content creator` and also to generate the `up and down SQL Statements`. 7. Generating the up and down `SQL statements` allows us to run the `apis/migrate` API, followed by `v1/metadata` for tracking the table.

## Generating a SQL Statement using ContentQL Metadata

Check out the documentation on the `sql-table-generator` package in `npm`.

```sh
npm i sql-table-generator
```

> I might change the ideology of how we design this `npm` package but, so the docs related to it can be found in the `README` of the package itself.
